-----Task 2
--1.1) Read committed (which is also read uncommitted in postgresql)
--When I tryed to update account name in termunal 2, there was no changes in terminal 1 until I commined in terminal 2. So, terminals shows different information until commited. That's because read committed isolation level guarantees that any data for reading was already committed at the moment.
--When I tryed to update balance in terminal 1, it immediatly updates (data updated in terminal 1 only), but in terminal 2 when i tryed to update, it stucks until i have committed in terminal 1. So, balance was correctly updated (+10 from terminal 1 and +20 from terminal 2, +30 total), then correctly rollbacked in terminal 2. Because of read committed isolaion guarantees, terminal 2 can not perform update on locked value (until it commited), overwise it will be dirty read with error.
--1.2) In case of repeatable read, i have the some different results compared with read committed when changing username. When second terminal changes username and commited, first terminal still see previous name that was before commit. Because repeatable read also have guarantees of the data read was commited AND data that was read will not change even if it is committed.
--Task with balance changing also shows the same results as read committed, second terminal waits until first one commits and then second terminal updates.
--2.1) Read commited. When I updated Bob's group to group 2 in terminal 2, there were no changes in terminal's 1 read operation. No changes because second terminal was not commited yet, and read committed isolaion level guarantees that values which commited only will be read. So, when I updated balances in first terminal, and then commited all terminals, there was only 'mike' with updated balance, and bob has no changes.
--2.2)Using repeatable read, I have obtained the same results as in Read commited. 